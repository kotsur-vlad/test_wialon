{"version":3,"sources":["Row.js","App.js","serviceWorker.js","index.js"],"names":["Row","React","memo","props","className","lat","lng","address","distance","libraries","center","mapContainerStyle","height","width","options","disableDefaultUI","disableDoubleClickZoom","zoomControl","App","useLoadScript","googleMapsApiKey","process","isLoaded","loadError","mapRef","useRef","onMapLoad","useCallback","map","current","useState","coordinates","setCoordinates","activeResult","setActiveResult","results","setResults","getCoordinates","e","parseInt","latLng","getGeocodingAPI","location","a","getGeocode","data","formatted_address","console","error","onGeocodingButtonClick","then","getDistance","destination","c","getOptions","length","origins","destinations","travelMode","res","i","key","r","reduce","sum","curr","type","placeholder","readOnly","value","onClick","zoom","onDblClick","onLoad","position","onCloseClick","callback","response","status","destinationAddresses","rows","elements","text","log","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.8771f68d.chunk.js","sourcesContent":["import React from \"react\"\r\n\r\nexport const Row = React.memo((props) => {\r\n\treturn (\r\n\t\t<div className=\"history_row\">\r\n\t\t\t<div>\r\n\t\t\t\t{props.lat}\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t{props.lng}\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t{props.address}\r\n\t\t\t</div>\r\n\t\t\t<div>\r\n\t\t\t\t{props.distance}\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t)\r\n})","import React, {useCallback, useState} from \"react\"\nimport {DistanceMatrixService, GoogleMap, InfoWindow, Marker, useLoadScript} from \"@react-google-maps/api\"\nimport {getGeocode} from \"use-places-autocomplete\"\n\nimport \"./App.css\"\nimport {Row} from \"./Row\"\n\n//Settings for map component\nconst libraries = [\"places\"]\nconst center = {\n\tlat: 53.709808,\n\tlng: 27.953388,\n}\nconst mapContainerStyle = {\n\theight: \"100vh\",\n\twidth: \"100%\",\n}\nconst options = {\n\tdisableDefaultUI: true,\n\tdisableDoubleClickZoom: true,\n\tzoomControl: true,\n}\n\nfunction App () {\n\tconst {isLoaded, loadError} = useLoadScript({\n\t\tgoogleMapsApiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY,\n\t\tlibraries,\n\t})\n\tconst mapRef = React.useRef()\n\tconst onMapLoad = React.useCallback((map) => {\n\t\tmapRef.current = map\n\t}, [])\n\n\t//State\n\tconst [coordinates, setCoordinates] = useState({\n\t\tlat: \"\",\n\t\tlng: \"\",\n\t})\n\tconst [activeResult, setActiveResult] = useState({})\n\tconst [results, setResults] = useState([])\n\n\t//Receiving coordinates from click\n\tconst getCoordinates = useCallback((e) => {\n\t\tsetCoordinates({\n\t\t\tlat: (parseInt(e.latLng.lat() * 1000000)) / 1000000,\n\t\t\tlng: (parseInt(e.latLng.lng() * 1000000)) / 1000000,\n\t\t})\n\t\tsetActiveResult(null)\n\t}, [])\n\n\t//Receiving geocoding request\n\tconst getGeocodingAPI = async (location) => {\n\t\ttry {\n\t\t\tconst data = await getGeocode(location)\n\t\t\treturn data[0].formatted_address\n\t\t} catch (error) {\n\t\t\tconsole.error(\"Ошибка при выполнении геокодинга\", error)\n\t\t}\n\t}\n\n\t//Display result after geocoding\n\tconst onGeocodingButtonClick = useCallback(() => {\n\t\tsetActiveResult(null)\n\t\tgetGeocodingAPI({location: coordinates})\n\t\t.then(address => {\n\t\t\tconst activeResult = {\n\t\t\t\tlat: coordinates.lat,\n\t\t\t\tlng: coordinates.lng,\n\t\t\t\taddress: address,\n\t\t\t\tdistance: 0,\n\t\t\t}\n\t\t\t// console.log(activeResult)\n\t\t\tsetResults((current) => [\n\t\t\t\t...current,\n\t\t\t\tactiveResult,\n\t\t\t])\n\t\t\tsetActiveResult(activeResult)\n\t\t})\n\t}, [coordinates])\n\n\t//Receiving distance between last 2 points\n\tconst getDistance = useCallback((destination, distance) => {\n\t\tsetResults((current) => current.map(c => {\n\t\t\t\tif (c.address === destination) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...c,\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t}\n\t\t\t\t} else return c\n\t\t\t}),\n\t\t)\n\t}, [])\n\n\t//Receiving options for distance request\n\tconst getOptions = useCallback(() => {\n\t\tif (results.length > 1) {\n\t\t\treturn {\n\t\t\t\torigins: [{\n\t\t\t\t\tlat: results[results.length - 2].lat,\n\t\t\t\t\tlng: results[results.length - 2].lng,\n\t\t\t\t}],\n\t\t\t\tdestinations: [{\n\t\t\t\t\tlat: results[results.length - 1].lat,\n\t\t\t\t\tlng: results[results.length - 1].lng,\n\t\t\t\t}],\n\t\t\t\ttravelMode: \"DRIVING\",\n\t\t\t}\n\t\t} else return null\n\t}, [results])\n\n\tconst renderMap = () => {\n\t\treturn (\n\t\t\t<div className=\"App\">\n\n\t\t\t\t<div className=\"history\">\n\t\t\t\t\t<Row lat={\"Широта\"}\n\t\t\t\t\t\t lng={\"Долгота\"}\n\t\t\t\t\t\t address={\"Адрес\"}\n\t\t\t\t\t\t distance={\"Расстояние от последней точки\"}/>\n\n\t\t\t\t\t{\n\t\t\t\t\t\tresults.map((res, i) => <Row key={i}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t lat={res.lat}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t lng={res.lng}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t address={res.address}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t distance={res.distance}/>)\n\t\t\t\t\t}\n\n\t\t\t\t\t<div className=\"total_distance\">\n\t\t\t\t\t\tОбщее расстояние: {\n\t\t\t\t\t\tresults.map(r => parseInt(r.distance))\n\t\t\t\t\t\t.reduce((sum, curr) => sum + curr, 0)\n\t\t\t\t\t} км\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<div className=\"geocode\">\n\t\t\t\t\t<input type=\"text\"\n\t\t\t\t\t\t   placeholder=\"широта\"\n\t\t\t\t\t\t   readOnly\n\t\t\t\t\t\t   value={coordinates.lat}\n\t\t\t\t\t/>\n\t\t\t\t\t<input type=\"text\"\n\t\t\t\t\t\t   placeholder=\"долгота\"\n\t\t\t\t\t\t   readOnly\n\t\t\t\t\t\t   value={coordinates.lng}\n\t\t\t\t\t/>\n\t\t\t\t\t<button className=\"geocode_button\"\n\t\t\t\t\t\t\tonClick={onGeocodingButtonClick}>\n\t\t\t\t\t\tГеокодировать\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\n\t\t\t\t<GoogleMap center={center}\n\t\t\t\t\t\t   mapContainerStyle={mapContainerStyle}\n\t\t\t\t\t\t   options={options}\n\t\t\t\t\t\t   zoom={7}\n\t\t\t\t\t\t   onDblClick={getCoordinates}\n\t\t\t\t\t\t   onLoad={onMapLoad}>\n\n\t\t\t\t\t<Marker position={coordinates}>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tactiveResult ? (<InfoWindow onCloseClick={() => setActiveResult(null)}>\n\t\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tactiveResult.address\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</InfoWindow>) : null\n\t\t\t\t\t\t}\n\t\t\t\t\t</Marker>\n\n\t\t\t\t\t{\n\t\t\t\t\t\tresults.length > 1 ? (\n\t\t\t\t\t\t\t<DistanceMatrixService options={getOptions()}\n\t\t\t\t\t\t\t\t\t\t\t\t   callback={(response, status) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t   if (status === \"OK\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   getDistance(response.destinationAddresses[0], response.rows[0].elements[0].distance.text)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   // console.log(\"Расстояние: \", response.rows[0].elements[0].distance.text)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   // console.log(\"Ответ: \", response)\n\t\t\t\t\t\t\t\t\t\t\t\t\t   } else console.log(status)\n\t\t\t\t\t\t\t\t\t\t\t\t   }}/>\n\t\t\t\t\t\t) : null\n\t\t\t\t\t}\n\t\t\t\t</GoogleMap>\n\t\t\t</div>\n\t\t)\n\t}\n\n\tif (loadError) {\n\t\treturn (\n\t\t\t<div>Карта сейчас не может быть загружена.</div>\n\t\t)\n\t}\n\treturn isLoaded ? renderMap() : <div>Загрузка карты.</div>\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}